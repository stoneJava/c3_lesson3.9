#include <iostream>  
using namespace std;

/**
 * C++程序的内存被分为堆（heap），栈（stack），全局/静态存储区，自由存储区和常量存储区。
1）堆（heap）：new的都存放在这里，属于动态分配，如果在程序中调用delete释放掉，那么将一直存在，直到程序结束，由程序释放掉。
2）栈（stack）：由系统自动分配，形参和局部变量均存储在这里，函数退出时该栈自动销毁。
3）全局/静态存储区：程序一开始执行即分配，生命周期持续到程序结束，存放全局变量，静态变量。
4）自由存储区域：与堆的区别在于存放的是malloc的。
5）常量存储区：顾名思义，存放常量的存储区。

明白了C++的内存管理，接下来函数调用过程就比较好理解了。
注意：栈空间是从高地址向低地址增长的。所以压栈即表示栈顶指针变小，而出栈则相反。
函数调用者维护了一个栈空间（stack），拥有栈底指针ebp和栈顶指针esp。

调用函数时，栈变化过程简单描述如下：
1）先将函数返回地址ret压栈，即函数执行完毕后将从哪里继续执行下去
2）将ebp压栈
3）讲esp赋值给ebp
4）将函数局部变量压栈

函数执行完毕后，栈变化过程如下：
1）函数局部变量出栈
2）ebp出栈，恢复ebp的值
3）函数返回地址出栈

从以上的变化过程可以看到，函数调用者通过操作ebp和esp的值变化来维护栈的变化。即是，虽然函数执行完毕后栈“销毁”了，但在重入之前，存储在栈中的数据仍然存在！这个时候，
 通过指针来访问该位置仍然可以获得正确的值！
但是为什么不推荐使用这种方式来获得局部变量的值呢？原因也是显而易见的，栈随时会被重入！重入之后，对应位置的值变成了不可预测，访问它会导致不可预测的后果。
那在什么情况下可以通过函数返回指针的方式来访问函数局部变量呢？参照C++的内存管理，答案很明显，
 new的变量在函数结束之后仍然可以通过指针“安全”地访问！但这其实带来了新的问题：你要负责管理这个变量的生命周期或者任由它生存到程序结束（可能白白占用了内存！）
一个简单的例子如下：
 */
int func1(int param)  
{  
    int local_param = param;  
  
    return local_param;  
}  
  //错误，返回的是函数内部的指针
int* func2(int param)
{
    //不是new  产生的，保存在栈中，在函数结束时自动销毁
    int local_param = param;  
  
    return &local_param;  
}
  
  
int *func3(int param)  
{
    //new的变量在函数结束之后仍然可以通过指针“安全”地访问！
    // 但这其实带来了新的问题：你要负责管理这个变量的生命周期或者任由它生存到程序结束（可能白白占用了内存！）
    int *new_param = new int(param);  
  
    return new_param;  
}  
  
  
int main()  
{  
    int *pNewVar = func3(3);  
    int *pVar = func2(2);
  
    cout << pVar << endl;
    cout << pNewVar << endl;  
    cout << func1(1) << endl;
    cout << pVar << endl;
    cout << pNewVar << endl;  
  
    return 0;  
}  